<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="dinu.PNG">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer Networks-I (TCS-604) Solved Papers</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        details > summary {
            cursor: pointer;
            padding: 1rem;
            background-color: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s ease;
        }
        details > summary:hover {
            background-color: #e5e7eb;
        }
        details[open] > summary {
            background-color: #e5e7eb;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        details > div {
            padding: 1.5rem;
            border: 1px solid #e5e7eb;
            border-top: 0;
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
        details details > summary {
            background-color: #ffffff;
            font-weight: 500;
        }
        details details > summary:hover {
            background-color: #f9fafb;
        }
        details details[open] > summary {
            background-color: #f9fafb;
        }
        details details > div {
            border-color: #f3f4f6;
            background-color: #fafcff;
        }
        .question-block {
            margin-bottom: 1rem;
        }
        .question-block h4 {
            font-weight: 600;
            color: #111827;
            margin-bottom: 0.5rem;
        }
        .question-block p, .question-block ul, .question-block ol {
            margin-bottom: 1rem;
            line-height: 1.6;
            color: #374151;
        }
        .question-block ul, .question-block ol {
            margin-left: 1.5rem;
        }
        .question-block ul {
            list-style-type: disc;
        }
        .question-block ol {
            list-style-type: decimal;
        }
        .question-block code {
            font-family: monospace;
            background-color: #f3f4f6;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
        }
        .question-block pre {
            background-color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
        }
        .repeat-note {
            background-color: #e0f2fe;
            border-l-4: border-blue-500;
            color: #0c546e;
            padding: 0.75rem 1.25rem;
            margin-bottom: 1rem;
            border: 1px solid #b3e5fc;
            border-left-width: 4px;
            border-radius: 0.375rem;
            font-size: 0.875rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="max-w-4xl mx-auto p-4 md:p-8">
        <h1 class="text-3xl font-bold text-center mb-8 text-blue-800">Computer Networks-I (TCS-604) Solved Papers <br>TERE EXAM KI MKC 6 BAR</h1>

        <!-- Paper 2025 -->
        <details class="mb-4">
            <summary class="text-xl">TCS-604 End Term Examination - May-June 2025</summary>
            <div class="space-y-4 bg-white">
                
                <!-- Q1 2025 -->
                <details>
                    <summary>Question 1</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <h4>a. Analyze the impact of propagation delay in satellite communication. What layer is affected the most and why?</h4>
                            <p><strong>Impact of Propagation Delay:</strong> Satellite communication, especially with geostationary (GEO) satellites, involves signals traveling a very long distance (approx. 35,786 km up and 35,786 km down). This results in a very high propagation delay (the time it takes for a signal to travel). A typical round-trip time (RTT) for a GEO satellite link is <strong>500-600 milliseconds</strong>.</p>
                            <p><strong>Layer Most Affected:</strong> While the delay physically originates at the <strong>Physical Layer (Layer 1)</strong>, its performance impact is most significantly felt at the <strong>Transport Layer (Layer 4)</strong>, specifically when using <strong>TCP</strong>.</p>
                            <p><strong>Why TCP is Affected:</strong></p>
                            <ul>
                                <li><strong>Slow Start:</strong> TCP's congestion control begins with the "Slow Start" algorithm, which doubles the congestion window (<code>cwnd</code>) every RTT. With a 500ms RTT, it takes a very long time to ramp up to use the available bandwidth.</li>
                                <li><strong>Congestion Control:</strong> TCP relies on ACKs to "clock" data out and to detect packet loss. The long delay in receiving ACKs (or detecting their absence via timeout) makes TCP's congestion avoidance and recovery mechanisms very slow to react.</li>
                                <li><strong>Handshake:</strong> The initial 3-way handshake to establish the connection takes at least 1 RTT (500+ ms) before any data can even be sent.</li>
                                <li><strong>Application Layer Impact:</strong> This high latency also severely impacts real-time <strong>Application Layer (Layer 7)</strong> protocols like VoIP or video conferencing, causing noticeable lag in conversation.</li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <h4>b. A packet of 1000 bytes is sent on a 10 Mbps link with 100ms propagation delay. Calculate the total delay.</h4>
                            <p>Total Delay is the sum of Transmission Delay and Propagation Delay.</p>
                            <ol>
                                <li><strong>Transmission Delay ($D_{trans}$):</strong> The time to push the packet's bits onto the link.
                                    <ul>
                                        <li>Packet Size = 1000 bytes = 1000 * 8 bits = 8000 bits</li>
                                        <li>Bandwidth = 10 Mbps = 10 * $10^6$ bits/sec = 10,000,000 bits/sec</li>
                                        <li>$D_{trans}$ = Packet Size / Bandwidth = 8000 / 10,000,000 sec</li>
                                        <li>$D_{trans}$ = 0.0008 seconds = <strong>0.8 milliseconds (ms)</strong></li>
                                    </ul>
                                </li>
                                <li><strong>Propagation Delay ($D_{prop}$):</strong> The time for the first bit to travel from sender to receiver.
                                    <ul>
                                        <li>$D_{prop}$ = <strong>100 ms</strong> (given)</li>
                                    </ul>
                                </li>
                                <li><strong>Total Delay:</strong>
                                    <ul>
                                        <li>Total Delay = $D_{trans}$ + $D_{prop}$</li>
                                        <li>Total Delay = 0.8 ms + 100 ms = <strong>100.8 ms</strong></li>
                                    </ul>
                                </li>
                            </ol>
                            <p>(Note: In this case, the transmission delay is negligible compared to the propagation delay, which is common in high-delay networks).</p>
                        </div>
                        <div class="question-block">
                            <h4>c. Discuss the lifecycle of an email using SMTP and POP3 or IMAP protocols.</h4>
                            <p>The lifecycle of an email involves two main stages: transfer (using SMTP) and access (using POP3 or IMAP).</p>
                            <ol>
                                <li><strong>Composition:</strong> The sender (e.g., Alice) composes a message in her User Agent (UA), like Outlook or Gmail.</li>
                                <li><strong>Transfer (SMTP):</strong>
                                    <ul>
                                        <li>Alice's UA sends the message to her outgoing <strong>Mail Server (MTA)</strong> using <strong>SMTP</strong> (Simple Mail Transfer Protocol).</li>
                                        <li>Alice's MTA acts as an SMTP client. It uses <strong>DNS</strong> (querying for an MX record) to find the IP address of the recipient's (e.g., Bob's) incoming Mail Server.</li>
                                        <li>Alice's MTA establishes a TCP connection (on port 25) to Bob's MTA and transfers the email using a series of SMTP commands (<code>HELO</code>, <code>MAIL FROM</code>, <code>RCPT TO</code>, <code>DATA</code>).</li>
                                        <li>Bob's MTA receives the email and places it in Bob's mailbox on that server.</li>
                                    </ul>
                                </li>
                                <li><strong>Access (POP3 vs. IMAP):</strong>
                                    <ul>
                                        <li>Bob's UA (mail client) connects to his incoming mail server to retrieve the message. This uses either POP3 or IMAP.</li>
                                        <li><strong>Using POP3 (Post Office Protocol 3):</strong> This is a "download and delete" protocol. Bob's client connects, authenticates, and downloads all new emails to his local machine. By default, the emails are then deleted from the server. The state (read/unread, folders) is kept on the client.</li>
                                        <li><strong>Using IMAP (Internet Message Access Protocol):</strong> This is a server-sync protocol. Bob's client connects and syncs with the server. All emails and folders are kept on the server. The client just displays a local copy. State (read/unread) is synced across all devices. This is the modern standard as it allows access from multiple devices (phone, laptop, etc.).</li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </div>
                </details>

                <!-- Q2 2025 -->
                <details>
                    <summary>Question 2</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <h4>a. Analyze how BitTorrent's use of parallel downloads increases performance compared to traditional FTP.</h4>
                            <p><strong>FTP (File Transfer Protocol):</strong></p>
                            <ul>
                                <li>FTP uses a client-server model. A single server stores the file, and all clients connect directly to this server to download it.</li>
                                <li>The server's upload bandwidth is a central bottleneck. If 100 clients are downloading, they all share this one source. Performance degrades rapidly as more users join.</li>
                            </ul>
                            <p><strong>BitTorrent (Peer-to-Peer):</strong></p>
                            <ul>
                                <li>BitTorrent uses a peer-to-peer (P2P) model. The file is broken into many small "pieces".</li>
                                <li>A "tracker" server helps peers find each other, but it does not host the file.</li>
                                <li><strong>Parallel Downloads:</strong> A new downloader (peer) gets pieces from *multiple* other peers *simultaneously*. Instead of one download stream from one server, it has many download streams from many peers.</li>
                                <li><strong>Scalability:</strong> As soon as a peer downloads a piece, it can *upload* that same piece to other peers. This means every new downloader also becomes an uploader. As more peers join the "swarm," the total available upload bandwidth of the swarm *increases*.</li>
                            </ul>
                            <p><strong>Conclusion:</strong> FTP performance scales *poorly* (one source, many clients), while BitTorrent performance scales *brilliantly* (every client is also a source), enabling much faster downloads for popular files.</p>
                        </div>
                        <div class="question-block">
                            <h4>b. A DNS resolver queries 3 servers sequentially with RTTs of 60 ms, 30 ms, and 10 ms respectively. What is the total time to resolve the name?</h4>
                            <p>This question describes an <strong>iterative query</strong> process from the perspective of a local DNS resolver.</p>
                            <ol>
                                <li>The resolver contacts the first server (e.g., Root Server). This takes one RTT. Time = <strong>60 ms</strong>.</li>
                                <li>The resolver contacts the second server (e.g., TLD Server). This takes one RTT. Time = <strong>30 ms</strong>.</li>
                                <li>The resolver contacts the third server (e.g., Authoritative Server). This takes one RTT. Time = <strong>10 ms</strong>.</li>
                            </ol>
                            <p>Since the queries are sequential (one after the other), the total time is the sum of all the RTTs.</p>
                            <p>Total Time = 60 ms + 30 ms + 10 ms = <strong>100 ms</strong></p>
                        </div>
                        <div class="question-block">
                            <h4>c. Discuss why layering helps in designing complex network protocols.</h4>
                            <p>Layering is a fundamental design principle that uses abstraction to manage the complexity of network communication. It helps in several key ways:</p>
                            <ul>
                                <li><strong>Modularity:</strong> It breaks down the single, massive problem of "network communication" into a set of smaller, more manageable sub-problems (layers). Each layer solves one part of the problem.</li>
                                <li><strong>Abstraction:</strong> Each layer provides a set of services to the layer above it, while hiding the complex details of *how* it implements those services. For example, the Application Layer (HTTP) just "sends data" without needing to know if it's over Wi-Fi, Ethernet, or how TCP is managing reliability.</li>
                                <li><strong>Interoperability:</strong> Layering promotes standardization. As long as a vendor's product correctly implements a layer's interface (e.g., a Wi-Fi card at Layer 2), it will work with products from other vendors at Layer 3 (e.g., Microsoft's IP stack).</li>
                                <li><strong>Ease of Maintenance and Updating:</strong> You can change the implementation of one layer without affecting any other layer. For example, you can upgrade your physical network from Ethernet (Layer 1/2) to faster Wi-Fi 6 (Layer 1/2) without changing your web browser (Layer 7) or your computer's TCP/IP stack (Layer 3/4).</li>
                            </ul>
                        </div>
                    </div>
                </details>

                <!-- Q3 2025 -->
                <details>
                    <summary>Question 3</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2024 - Q1.a). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>a. Describe the role of encapsulation and decapsulation in layered protocol communication.</h4>
                            <p><strong>Encapsulation (On the Sending Side):</strong></p>
                            <p>As data moves *down* the protocol stack (from Application to Physical), each layer "wraps" the data it receives from the layer above by adding its own control information, called a <strong>header</strong> (and sometimes a trailer).</p>
                            <ul>
                                <li><strong>Application Layer:</strong> Creates the message (e.g., "GET /index.html").</li>
                                <li><strong>Transport Layer:</strong> Takes the message, adds a TCP header (with ports, seq/ack numbers) to create a <strong>segment</strong>.</li>
                                <li><strong>Network Layer:</strong> Takes the segment, adds an IP header (with source/dest IP) to create a <strong>datagram</strong>.</li>
                                <li><strong>Link Layer:</strong> Takes the datagram, adds a Link header (with MAC addresses) to create a <strong>frame</strong>.</li>
                                <li><strong>Physical Layer:</strong> Transmits the frame as raw bits.</li>
                            </ul>
                            <p><strong>Decapsulation (On the Receiving Side):</strong></p>
                            <p>As data moves *up* the protocol stack, each layer "unwraps" the data by reading its header, processing it, and then stripping it off before passing the payload to the layer above.</p>
                            <ul>
                                <li><strong>Link Layer:</strong> Receives the frame, checks the MAC address, strips the Link header, and passes the datagram up.</li>
                                <li><strong>Network Layer:</strong> Receives the datagram, checks the IP address, strips the IP header, and passes the segment up.</li>
                                <li><strong>Transport Layer:</strong> Receives the segment, checks the port, strips the TCP header, and passes the message up.</li>
                                <li><strong>Application Layer:</strong> Receives the original message.</li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <h4>b. Given a 5-layered model, if each layer adds a 20-byte header and a message is 200 bytes, what is the total transmission size?</h4>
                            <p>This is slightly ambiguous, but the standard interpretation of the 5-layer (Internet) model is that the Application Layer *creates* the message, and the next 3 layers add headers (Physical layer deals in bits and doesn't add a header).</p>
                            <p>Let's assume the 5 layers are App, Transport, Network, Link, Physical.</p>
                            <ol>
                                <li><strong>Application Layer (L5):</strong> Message = <strong>200 bytes</strong></li>
                                <li><strong>Transport Layer (L4):</strong> Adds 20-byte header. Size = 200 + 20 = 220 bytes.</li>
                                <li><strong>Network Layer (L3):</strong> Adds 20-byte header. Size = 220 + 20 = 240 bytes.</li>
                                <li><strong>Link Layer (L2):</strong> Adds 20-byte header. Size = 240 + 20 = <strong>260 bytes</strong>.</li>
                                <li><strong>Physical Layer (L1):</strong> Transmits the 260 bytes as bits.</li>
                            </ol>
                            <p>The total transmission size (the frame size on the wire, excluding physical-layer overhead) is <strong>260 bytes</strong>.</p>
                            <p>(If the question literally means 5 layers *all* add headers, it would be 200 + 5*20 = 300 bytes, but this doesn't map to a standard model).</p>
                        </div>
                        <div class="question-block">
                            <h4>c. Compare and contrast persistent vs non-persistent HTTP. Under what circumstances is each preferred?</h4>
                            <p><strong>Non-Persistent HTTP (HTTP/1.0):</strong></p>
                            <ul>
                                <li><strong>Process:</strong>
                                    1. Client opens a new TCP connection to the server.
                                    2. Client sends one HTTP request.
                                    3. Server sends one HTTP response.
                                    4. Server *closes* the TCP connection.
                                </li>
                                <li><strong>Problem:</strong> A modern webpage contains 1 HTML file + 10 images. This would require <strong>11 separate TCP connections</strong>. The overhead of setting up and tearing down each connection (3-way handshake, slow start) makes this extremely slow.</li>
                            </ul>
                            <p><strong>Persistent HTTP (HTTP/1.1 Default):</strong></p>
                            <ul>
                                <li><strong>Process:</strong>
                                    1. Client opens a TCP connection to the server.
                                    2. Client sends an HTTP request.
                                    3. Server sends an HTTP response.
                                    4. The TCP connection <strong>stays open</strong>.
                                    5. Client can send more requests (e.g., for all 10 images) over the *same* connection.
                                </li>
                                <li><strong>Benefit:</strong> Drastically reduces latency by eliminating the repeated connection setup overhead.</li>
                            </ul>
                            <p><strong>When Preferred:</strong></p>
                            <ul>
                                <li><strong>Non-Persistent:</strong> Almost never preferred today. It is a legacy model that is highly inefficient for modern, media-rich websites.</li>
                                <li><strong>Persistent:</strong> Preferred for <strong>all modern web browsing</strong>. It is the default for HTTP/1.1 and the basis for HTTP/2 (which uses a single, multiplexed connection).</li>
                            </ul>
                        </div>
                    </div>
                </details>

                <!-- Q4 2025 -->
                <details>
                    <summary>Question 4</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <h4>a. Analyze the working of cookies in maintaining state in stateless HTTP connections. What are the security and privacy concerns associated with them?</h4>
                            <p><strong>Working of Cookies:</strong></p>
                            <p>HTTP is a "stateless" protocol, meaning each request is independent; the server forgets about the client as soon as the response is sent. This is bad for shopping carts or logins. Cookies fix this:</p>
                            <ol>
                                <li><strong>Server Sends Cookie:</strong> When you first log in, the server sends a response with a <code>Set-Cookie:</code> header (e.g., <code>Set-Cookie: sessionID=abc12345</code>).</li>
                                <li><strong>Browser Stores Cookie:</strong> The browser saves this <code>sessionID=abc12345</code> text file, tying it to the server's domain (e.g., <code>amazon.com</code>).</li>
                                <li><strong>Browser Sends Cookie:</strong> On *every subsequent request* to <code>amazon.com</code>, the browser automatically includes a <code>Cookie:</code> header (e.g., <code>Cookie: sessionID=abc12345</code>).</li>
                                <li><strong>Server Remembers:</strong> The server reads this <code>sessionID</code>, looks it up in its database, and "remembers" who you are, keeping you logged in.</li>
                            </ol>
                            <p><strong>Security Concerns:</strong></p>
                            <ul>
                                <li><strong>Session Hijacking:</strong> If an attacker steals your session cookie (e.g., on unencrypted Wi-Fi), they can use it to impersonate you. (Mitigation: Use HTTPS, set <code>Secure</code> flag on cookie).</li>
                                <li><strong>Cross-Site Scripting (XSS):</strong> If a website has an XSS flaw, an attacker can inject a script to steal the cookie. (Mitigation: Set <code>HttpOnly</code> flag so scripts can't access it).</li>
                            </ul>
                            <p><strong>Privacy Concerns:</strong></p>
                            <ul>
                                <li><strong>Tracking:</strong> This is the main concern. <strong>Third-party cookies</strong> (from ad networks) can be placed on your browser by one site (e.g., <code>news.com</code>) and read by another (e.g., <code>shopping.com</code>) if both use the same ad network. This allows ad networks to build a detailed profile of your browsing habits across the entire web.</li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2023 - Q4.c and 2024 - Q4.c). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>b. A network engineer is evaluating... Stop-and-Wait, Go-Back-N, and Selective Repeat...</h4>
                            <p>This question asks for a comparison of three Reliable Data Transfer (RDT) protocols.</p>
                            <ul>
                                <li><strong>Stop-and-Wait:</strong>
                                    <ul>
                                        <li><strong>Performance:</strong> Very poor. Sender window size = 1. It sends one packet and waits for the ACK. The link is idle for most of the RTT. Utilization is very low.</li>
                                        <li><strong>Complexity:</strong> Very simple. Receiver logic is trivial.</li>
                                        <li><strong>Retransmission:</strong> On timeout, retransmits the one un-ACKed packet.</li>
                                    </ul>
                                </li>
                                <li><strong>Go-Back-N (GBN):</strong>
                                    <ul>
                                        <li><strong>Performance:</strong> Good. Sender window size = N. Allows "pipelining" (sending N packets without waiting for ACKs), which keeps the link busy.</li>
                                        <li><strong>Complexity:</strong> Moderate. Sender is complex, but receiver is simple (it only accepts in-order packets and discards all out-of-order packets).</li>
                                        <li><strong>Retransmission:</strong> Uses *cumulative ACKs* (ACK `n` means `n` and all before it are received). If packet `n` is lost, the sender's timer expires, and it retransmits packet `n` *and all subsequent packets* in the window (`n+1`, `n+2`, ...) even if they were received correctly. This is wasteful.</li>
                                    </ul>
                                </li>
                                <li><strong>Selective Repeat (SR):</strong>
                                    <ul>
                                        <li><strong>Performance:</strong> Excellent. Sender window size = N. Allows pipelining.</li>
                                        <li><strong>Complexity:</strong> High. *Both* sender and receiver are complex. The receiver must *individually* ACK packets and buffer out-of-order packets for later delivery.</li>
                                        <li><strong>Retransmission:</strong> If packet `n` is lost, the sender's timer for *only packet `n`* expires, and it retransmits *only packet `n`*. This is the most efficient retransmission strategy.</li>
                                    </ul>
                                </li>
                            </ul>
                            <p><strong>Selection Strategy:</strong></p>
                            <ul>
                                <li>Use <strong>Stop-and-Wait</strong> only if the bandwidth-delay product is tiny (e.g., a slow link with near-zero delay).</li>
                                <li>Use <strong>Go-Back-N</strong> if the receiver is very simple/memory-constrained.</li>
                                <li>Use <strong>Selective Repeat</strong> for most modern, high-bandwidth, high-delay networks (like the internet). It provides the best performance, and its complexity is worth the efficiency. (TCP's "Selective Acknowledgment" or SACK is a variant of SR).</li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <h4>c. Describe how TCP handles connection setup and teardown with state diagrams.</h4>
                            <p><strong>Connection Setup (Three-Way Handshake):</strong></p>
                            <ol>
                                <li><strong>Client (<code>CLOSED</code>) -> Server (<code>LISTEN</code>):</strong> Client sends a <strong>SYN</strong> packet (<code>Seq=x</code>). Client state becomes <code>SYN_SENT</code>.</li>
                                <li><strong>Server (<code>LISTEN</code>) -> Client (<code>SYN_SENT</code>):</strong> Server receives SYN. It replies with a <strong>SYN-ACK</strong> packet (<code>Seq=y, Ack=x+1</code>). Server state becomes <code>SYN_RCVD</code>.</li>
                                <li><strong>Client (<code>SYN_SENT</code>) -> Server (<code>SYN_RCVD</code>):</strong> Client receives SYN-ACK. It replies with an <strong>ACK</strong> packet (<code>Seq=x+1, Ack=y+1</code>). Client state becomes <code>ESTABLISHED</code>.</li>
                                <li>The server receives the final ACK and its state becomes <code>ESTABLISHED</code>. The connection is now open.</li>
                            </ol>
                            <p><strong>Connection Teardown (Four-Way Handshake):</strong></p>
                            <ol>
                                <li><strong>Side 1 (<code>ESTABLISHED</code>):</strong> Decides to close. Sends a <strong>FIN</strong> packet. State becomes <code>FIN_WAIT_1</code>.</li>
                                <li><strong>Side 2 (<code>ESTABLISHED</code>):</strong> Receives FIN. Sends an <strong>ACK</strong> to acknowledge it. State becomes <code>CLOSE_WAIT</code>. (It can still send data if it needs to).</li>
                                <li><strong>Side 1 (<code>FIN_WAIT_1</code>):</strong> Receives the ACK. State becomes <code>FIN_WAIT_2</code>.</li>
                                <li><strong>Side 2 (<code>CLOSE_WAIT</code>):</strong> When done sending data, it sends its own <strong>FIN</strong> packet. State becomes <code>LAST_ACK</code>.</li>
                                <li><strong>Side 1 (<code>FIN_WAIT_2</code>):</strong> Receives Side 2's FIN. Sends its final <strong>ACK</strong>. State becomes <code>TIME_WAIT</code> (it waits 2*MSL to ensure the ACK isn't lost).</li>
                                <li><strong>Side 2 (<code>LAST_ACK</code>):</strong> Receives the final ACK. State becomes <code>CLOSED</code>.</li>
                                <li><strong>Side 1 (<code>TIME_WAIT</code>):</strong> After the timer expires, state becomes <code>CLOSED</code>.</li>
                            </ol>
                        </div>
                    </div>
                </details>

                <!-- Q5 2025 -->
                <details>
                    <summary>Question 5</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2024 - Q4.b). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>a. Discuss how TCP implements flow control and congestion control mechanisms.</h4>
                            <p>These are two different mechanisms to "throttle" the sender, but for different reasons.</p>
                            <p><strong>Flow Control (Protects the Receiver):</strong></p>
                            <ul>
                                <li><strong>Purpose:</strong> To prevent the sender from sending data faster than the *receiver's application* can read it, (i.e., overflowing the *receiver's buffer*).</li>
                                <li><strong>Mechanism:</strong> The receiver advertises its available buffer space in every ACK it sends. This is the <strong>Receive Window (<code>rwnd</code>)</strong> field in the TCP header.
                                The sender maintains the rule: <code>LastByteSent - LastByteAcked <= rwnd</code>. If the receiver's buffer is full, it advertises <code>rwnd=0</code>, and the sender stops sending (except for small probe packets).</li>
                            </ul>
                            <p><strong>Congestion Control (Protects the Network):</strong></p>
                            <ul>
                                <li><strong>Purpose:</strong> To prevent the sender from sending data faster than the *network* (i.e., routers) can handle, (i.e., causing packet loss due to router buffer overflow).</li>
                                <li><strong>Mechanism:</strong> The sender maintains a *second* window, the <strong>Congestion Window (<code>cwnd</code>)</strong>. The actual number of un-ACKed bytes the sender can have is <code>min(rwnd, cwnd)</code>.
                                <code>cwnd</code> is adjusted based on *perceived network congestion* (i.e., packet loss).
                                <ul>
                                    <li><strong>Slow Start:</strong> <code>cwnd</code> starts at 1 MSS and grows exponentially (doubles every RTT).</li>
                                    <li><strong>Congestion Avoidance:</strong> After <code>cwnd</code> passes a threshold (<code>ssthresh</code>), it grows linearly (adds 1 MSS per RTT).</li>
                                    <li><strong>Congestion Detection:</strong>
                                        <ul>
                                            <li><strong>On 3 Duplicate ACKs (Packet loss):</strong> Halve <code>ssthresh</code>, set <code>cwnd</code> to new <code>ssthresh</code>, enter Congestion Avoidance. (Fast Recovery).</li>
                                            <li><strong>On Timeout (Severe congestion):</strong> Halve <code>ssthresh</code>, reset <code>cwnd</code> to 1, enter Slow Start.</li>
                                        </ul>
                                    </li>
                                </ul>
                                </li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2023 - Q5.c and 2024 - Q5.c). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>b. Discuss how NAT allows multiple devices to share one public IP address.</h4>
                            <p><strong>NAT (Network Address Translation)</strong> is a technique used by routers to solve the IPv4 address shortage. A typical home has many devices (laptops, phones) with *private* IPs (e.g., <code>192.168.1.x</code>) but only *one public IP* from the ISP (e.g., <code>123.45.67.89</code>).</p>
                            <p>Here's how it works:</p>
                            <ol>
                                <li><strong>Outbound Packet:</strong> Your laptop (<code>192.168.1.100</code>) sends a packet from port <code>5000</code> to <code>google.com</code> port <code>80</code>.
                                    <ul><li>(Source: <code>192.168.1.100:5000</code>, Dest: <code>google.com:80</code>)</li></ul>
                                </li>
                                <li><strong>NAT Router (Sending):</strong> The router receives this. It rewrites the source IP and port.
                                    <ul><li>It replaces the private source IP (<code>192.168.1.100</code>) with its *own public IP* (<code>123.45.67.89</code>).</li>
                                    <li>It replaces the source port (<code>5000</code>) with a new, random, unused port (e.g., <code>62000</code>).</li>
                                    <li>(New Source: <code>123.45.67.89:62000</code>, Dest: <code>google.com:80</code>)</li>
                                </ul>
                                </li>
                                <li><strong>NAT Table:</strong> The router records this mapping in a "NAT translation table":
                                    <code>(192.168.1.100:5000) <=> (123.45.67.89:62000)</code>
                                </li>
                                <li><strong>Inbound Packet:</strong> Google's server replies, sending the packet to the router's public IP and new port.
                                    <ul><li>(Source: <code>google.com:80</code>, Dest: <code>123.45.67.89:62000</code>)</li></ul>
                                </li>
                                <li><strong>NAT Router (Receiving):</strong> The router receives this. It looks up port <code>62000</code> in its NAT table.
                                    <li>It rewrites the destination IP and port back to the original private ones.</li>
                                    <li>(New Source: <code>google.com:80</code>, Dest: <code>192.168.1.100:5000</code>)</li>
                                </li>
                                <li>The packet is forwarded to your laptop. The laptop is unaware any of this happened.</li>
                            </ol>
                        </div>
                        <div class="question-block">
                            <h4>c. A company is allocated 192.168.10.0/24. It needs to create 5 subnets with at least 30 hosts each. Design the subnetting scheme.</h4>
                            <ol>
                                <li><strong>Host Requirement:</strong> We need 30 usable hosts per subnet.
                                    <ul>
                                        <li>The formula is $2^h - 2 \ge 30$, where `h` is the number of host bits.</li>
                                        <li>$2^4 - 2 = 14$ (Too small)</li>
                                        <li>$2^5 - 2 = 30$ (Perfect!)</li>
                                        <li>So, we must reserve <strong>5 bits for hosts (`h=5`)</strong>.</li>
                                    </ul>
                                </li>
                                <li><strong>Subnet Mask:</strong> A full IP address is 32 bits.
                                    <ul>
                                        <li>New network bits = 32 - `h` = 32 - 5 = 27.</li>
                                        <li>The new subnet mask is <strong>/27</strong>, which is <code>255.255.255.224</code>.</li>
                                    </ul>
                                </li>
                                <li><strong>Subnet Requirement:</strong> Does this mask give us 5 subnets?
                                    <ul>
                                        <li>The original mask was /24. The new is /27.</li>
                                        <li>We "borrowed" $s = 27 - 24 = 3$ bits for subnets.</li>
                                        <li>Number of subnets = $2^s = 2^3 = 8$ subnets.</li>
                                        <li>This meets the requirement of "at least 5 subnets".</li>
                                    </ul>
                                </li>
                                <li><strong>The Subnetting Scheme:</strong>
                                    <ul>
                                        <li>The "block size" is $2^h = 2^5 = 32$. We will increment the 4th octet by 32.</li>
                                        <li><strong>Subnet 1:</strong> <code>192.168.10.0/27</code> (Hosts: .1 to .30, Broadcast: .31)</li>
                                        <li><strong>Subnet 2:</strong> <code>192.168.10.32/27</code> (Hosts: .33 to .62, Broadcast: .63)</li>
                                        <li><strong>Subnet 3:</strong> <code>192.168.10.64/27</code> (Hosts: .65 to .94, Broadcast: .95)</li>
                                        <li><strong>Subnet 4:</strong> <code>192.168.10.96/27</code> (Hosts: .97 to .126, Broadcast: .127)</li>
                                        <li><strong>Subnet 5:</strong> <code>192.168.10.128/27</code> (Hosts: .129 to .158, Broadcast: .159)</li>
                                        <li>(Subnets .160, .192, and .224 are also available).</li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </div>
                </details>

            </div>
        </details>

        <!-- Paper 2024 -->
        <details class="mb-4">
            <summary class="text-xl">TCS-604 End Semester Examination - 2024</summary>
            <div class="space-y-4 bg-white">
                
                <!-- Q1 2024 -->
                <details>
                    <summary>Question 1</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2025 - Q3.a). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>a. What do encapsulation and De-encapsulation mean?</h4>
                            <p><strong>Encapsulation (Sending):</strong> As data moves *down* the protocol stack, each layer "wraps" the data from the layer above by adding its own header. (App Message -> [TCP Header + Message] = Segment -> [IP Header + Segment] = Datagram -> [Link Header + Datagram] = Frame).</p>
                            <p><strong>Decapsulation (Receiving):</strong> As data moves *up* the stack, each layer "unwraps" the data by reading its header, processing it, and stripping it off before passing the payload to the layer above.</p>
                        </div>
                        <div class="question-block">
                            <h4>b. Which layers in the Internet Protocol stack does a router process? Which layers does a switch process? Which layer does a host process?</h4>
                            <p>Using the 5-layer Internet model (Application, Transport, Network, Link, Physical):</p>
                            <ul>
                                <li><strong>Host (e.g., your laptop):</strong> Processes <strong>all 5 layers</strong>. It originates and terminates the data. It runs the application (L7), manages the TCP connection (L4), creates the IP packet (L3), frames it (L2), and sends the bits (L1).</li>
                                <li><strong>Router:</strong> Processes <strong>Layers 1, 2, and 3</strong>. It receives bits (L1), de-frames them (L2), and inspects the <strong>Network Layer (L3)</strong> IP header. It uses this IP header to make a forwarding decision (routing). It then re-frames the packet (L2) and sends the bits out (L1). It *does not* look at L4 or L7.</li>
                                <li><strong>Switch (L2 Switch):</strong> Processes <strong>Layers 1 and 2</strong>. It receives bits (L1) and inspects the <strong>Link Layer (L2)</strong> MAC address. It uses this MAC address to make a forwarding decision (switching). It *does not* look at L3, L4, or L7.</li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2023 - Q1.c). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>c. Consider two host A and B... Find the distance m so that $d_{prop}$ equals $d_{trans}$.</h4>
                            <p>Given:</p>
                            <ul>
                                <li>Propagation speed (s) = $2.5 \times 10^8$ m/s</li>
                                <li>Packet size (L) = 100 bits</li>
                                <li>Bandwidth (R) = 28 Kbps = 28,000 bits/sec</li>
                            </ul>
                            <p>We need to find distance `m` where $d_{prop} = d_{trans}$.</p>
                            <ol>
                                <li><strong>Formulas:</strong>
                                    <ul>
                                        <li>$d_{prop}$ = distance / speed = m / s</li>
                                        <li>$d_{trans}$ = size / bandwidth = L / R</li>
                                    </ul>
                                </li>
                                <li><strong>Set them equal:</strong>
                                    <ul>
                                        <li>m / s = L / R</li>
                                    </ul>
                                </li>
                                <li><strong>Solve for m:</strong>
                                    <ul>
                                        <li>m = (L * s) / R</li>
                                        <li>m = (100 bits * $2.5 \times 10^8$ m/s) / 28,000 bits/s</li>
                                        <li>m = (2.5 * $10^{10}$) / (2.8 * $10^4$)</li>
                                        <li>m = (2.5 / 2.8) * $10^6$</li>
                                        <li>m ≈ 0.892857 * $10^6$ meters</li>
                                        <li>m ≈ <strong>892,857 meters</strong> (or 892.86 km)</li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </div>
                </details>

                <!-- Q2 2024 -->
                <details>
                    <summary>Question 2</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <h4>a. How does TCP protocol provide reliablility? Write down the names of services provided by the TCP? Write the name of well known ports used by TCP.</h4>
                            <p><strong>How TCP provides reliability:</strong></p>
                            <ul>
                                <li><strong>Connection-Oriented:</strong> A 3-way handshake ensures both sender and receiver are ready before data is sent.</li>
                                <li><strong>Sequencing:</strong> Each byte is numbered. The receiver uses sequence numbers to reorder packets that arrive out-of-order.</li>
                                <li><strong>Acknowledgments (ACKs):</strong> The receiver sends cumulative ACKs to confirm which bytes it has received.</li>
                                <li><strong>Error Detection:</strong> A checksum field in the header detects corrupted segments.</li>
                                <li><strong>Retransmission:</strong> If the sender doesn't receive an ACK within a certain time (timeout) or receives 3 duplicate ACKs, it assumes the packet was lost and retransmits it.</li>
                            </ul>
                            <p><strong>Services provided by TCP:</strong></p>
                            <ul>
                                <li>Reliable Data Transfer</li>
                                <li>Connection-Oriented Service</li>
                                <li>Flow Control (protects the receiver)</li>
                                <li>Congestion Control (protects the network)</li>
                                <li>Full-Duplex Communication</li>
                                <li>Process-to-Process Delivery (using ports)</li>
                            </ul>
                            <p><strong>Well-Known Ports (TCP):</strong></p>
                            <ul>
                                <li><strong>20, 21:</strong> FTP (File Transfer Protocol)</li>
                                <li><strong>22:</strong> SSH (Secure Shell)</li>
                                <li><strong>23:</strong> Telnet</li>
                                <li><strong>25:</strong> SMTP (Simple Mail Transfer Protocol)</li>
                                <li><strong>53:</strong> DNS (also uses UDP 53)</li>
                                <li><strong>80:</strong> HTTP (Hypertext Transfer Protocol)</li>
                                <li><strong>110:</strong> POP3 (Post Office Protocol)</li>
                                <li><strong>143:</strong> IMAP (Internet Message Access Protocol)</li>
                                <li><strong>443:</strong> HTTPS (HTTP Secure)</li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <h4>b. Suppose Alice (webmail) sends a message to Bob (IMAP). Discuss how the message gets from Alice's host to Bob's host.</h4>
                            <p>This involves several protocols working in sequence:</p>
                            <ol>
                                <li><strong>Alice (Client) to Alice's Server (HTTP):</strong> Alice opens her web browser and logs into her webmail (e.g., Gmail). She composes and sends the email. This entire interaction between her browser and the Gmail server happens over <strong>HTTP</strong>.</li>
                                <li><strong>Alice's Server to Bob's Server (SMTP):</strong>
                                    <ul>
                                        <li>Gmail's mail server (MTA) receives the message. It now needs to send it to Bob's mail server.</li>
                                        <li>It uses <strong>DNS</strong> to find the MX (Mail Exchange) record for Bob's domain (e.g., <code>bob.com</code>) to get the IP of his mail server.</li>
                                        <li>Gmail's server (as an SMTP client) connects to Bob's mail server (as an SMTP server) using <strong>SMTP</strong> over port 25.</li>
                                        <li>It transfers the email.</li>
                                    </ul>
                                </li>
                                <li><strong>Bob (Client) to Bob's Server (IMAP):</strong>
                                    <ul>
                                        <li>Bob opens his local mail client (e.g., Outlook, Apple Mail).</li>
                                        <li>His client connects to his mail server using <strong>IMAP</strong>.</li>
                                        <li>IMAP syncs the state of the server with his client. He sees the new message from Alice, downloads it, and reads it.</li>
                                    </ul>
                                </li>
                            </ol>
                            <p><strong>Protocol Chain:</strong> <code>HTTP</code> (Alice) -> <code>DNS</code> (Server lookup) -> <code>SMTP</code> (Server-to-Server) -> <code>IMAP</code> (Bob)</p>
                        </div>
                        <div class="question-block">
                            <h4>c. What are the factors that influence the RTT. Why is the calculation of RTT is advantageous. Also what are the measures to reduce the RTT.</h4>
                            <p><strong>Factors influencing RTT (Round Trip Time):</strong></p>
                            <ul>
                                <li><strong>Propagation Delay:</strong> The time for a signal to travel the physical distance. This is the main, fixed component (e.g., speed of light in fiber).</li>
                                <li><strong>Processing Delay:</strong> Time taken by routers to examine a packet header.</li>
                                <li><strong>Queueing Delay:</strong> Time a packet spends waiting in a buffer (queue) at a congested router. This is the *most variable* component.</li>
                                <li><strong>Transmission Delay:</strong> Time to push the packet's bits onto the link (L/R).</li>
                            </ul>
                            <p><strong>Advantages of Calculating RTT:</strong></p>
                            <ul>
                                <li><strong>TCP Retransmission Timer:</strong> TCP must know the RTT to set a proper Retransmission Timeout (RTO). If the RTO is too short, it retransmits unnecessarily; too long, and it's slow to recover from loss.</li>
                                <li><strong>TCP Congestion Control:</strong> The RTT is used to "clock" the increase of the congestion window.</li>
                                <li><strong>Performance Diagnosis:</strong> Tools like `ping` use RTT to measure network latency and diagnose connectivity issues.</li>
                            </ul>
                            <p><strong>Measures to Reduce RTT:</strong></p>
                            <ul>
                                <li><strong>Content Delivery Network (CDN):</strong> This is the most effective method. A CDN caches content (images, videos) on servers *geographically closer* to the user, which drastically reduces the physical distance and thus the propagation delay.</li>
                                <li><strong>Improved Routing:</strong> Finding more direct network paths (e.g., better BGP peering).</li>
                                <li><strong>Reducing Congestion:</strong> Increasing bandwidth on links reduces queueing delay.
                                <li><strong>Protocol Optimization:</strong> Using persistent connections (HTTP/1.1) or QUIC (HTTP/3) reduces the number of RTTs needed for connection setup.</li>
                            </ul>
                        </div>
                    </div>
                </details>

                <!-- Q3 2024 -->
                <details>
                    <summary>Question 3</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <h4>a. What are the different services provided by the Transport layer? Explain the transport layer protocol used for DNS and also state why it is suitable for DNS.</h4>
                            <p><strong>Transport Layer Services:</strong></p>
                            <ul>
                                <li><strong>Process-to-Process Delivery:</strong> Using port numbers, it delivers data not just to a host (like IP) but to a *specific application process* on that host.</li>
                                <li><strong>Multiplexing / Demultiplexing:</strong> Gathers data from multiple app sockets (multiplexing) and delivers incoming data to the correct socket (demultiplexing).</li>
                                <li><strong>Connection-Oriented Service (TCP):</strong> Provides reliable, in-order delivery.</li>
                                <li><strong>Connectionless Service (UDP):</strong> Provides unreliable, "best-effort" delivery.</li>
                                <li><strong>Error Checking:</strong> Both TCP and UDP provide a checksum to detect bit errors.</li>
                            </ul>
                            <p><strong>Transport Protocol for DNS:</strong></p>
                            <p>DNS primarily uses <strong>UDP (User Datagram Protocol)</strong> on port 53.</p>
                            <p><strong>Why UDP is Suitable for DNS:</strong></p>
                            <ul>
                                <li><strong>Speed:</strong> DNS queries are small (one request packet, one response packet). UDP is connectionless, so there is no 3-way handshake. This saves an entire RTT, making DNS lookups very fast.</li>
                                <li><strong>Simplicity:</strong> If a DNS query packet is lost, the application (resolver) can simply time out and send the query again. It doesn't need the complex state and reliability mechanism of TCP.</li>
                            </ul>
                            <p><em>(Note: DNS *does* use TCP on port 53 for special cases, like large zone transfers between servers, where reliability is critical).</em></p>
                        </div>
                        <div class="question-block">
                            <h4>b. Suppose Host A and Host B use a GBN protocol with window size N=3... Draw the timing diagram...</h4>
                            <p>This requires a timing diagram showing the loss of `ACK1` and `Pkt5`.</p>
                            <pre>
Host A (Sender)         Host B (Receiver)
Window: [1,2,3]
Send Pkt1
                      Recv Pkt1
                      Send ACK1  (LOST)
Send Pkt2
                      Recv Pkt2
                      Send ACK2
Send Pkt3
                      Recv Pkt3
                      Send ACK3
Recv ACK2
Window: [3,4,5]
Send Pkt4
                      Recv Pkt4
                      Send ACK4
Recv ACK3
Window: [4,5,6]
Send Pkt5 (LOST)
Recv ACK4
Window: [5,6]
Send Pkt6
                      Recv Pkt6 (Out of order)
                      DISCARD Pkt6
                      Resend ACK4 (last in-order)

...Timer for Pkt5 expires...
(Sender goes back N)

Send Pkt5
                      Recv Pkt5
                      Send ACK5
Send Pkt6
                      Recv Pkt6
                      Send ACK6
Recv ACK5
Window: [6]
Recv ACK6
Window: []
                            </pre>
                        </div>
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2023 - Q3.c). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>c. ...what would be the IP address of E0... what would be the IP address of S0...</h4>
                            <p>Network: <code>192.168.10.0/28</code>. Mask: <code>255.255.255.240</code>. Block size = 16.
                            We are told to skip the "zero subnet" (subnet <code>.0</code>).</p>
                            
                            <p><strong>A: IP of E0 (eighth subnet, last available IP):</strong></p>
                            <ul>
                                <li>Subnet 1: .16</li>
                                <li>Subnet 2: .32</li>
                                <li>...</li>
                                <li>Subnet 8: <strong>.128</strong></li>
                                <li>Network ID: <code>192.168.10.128</code></li>
                                <li>Broadcast ID: <code>192.168.10.143</code> (128 + 16 - 1)</li>
                                <li>Host Range: .129 to .142</li>
                                <li>Last available IP: <strong>192.168.10.142</strong></li>
                            </ul>
                            
                            <p><strong>B: IP of S0 (first subnet, last available IP):</strong></p>
                            <ul>
                                <li>First subnet (skipping .0) is <strong>.16</strong></li>
                                <li>Network ID: <code>192.168.10.16</code></li>
                                <li>Broadcast ID: <code>192.168.10.31</code> (16 + 16 - 1)</li>
                                <li>Host Range: .17 to .30</li>
                                <li>Last available IP: <strong>192.168.10.30</strong></li>
                            </ul>
                        </div>
                    </div>
                </details>

                <!-- Q4 2024 -->
                <details>
                    <summary>Question 4</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2023 - Q4.a). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>a. ...Compute the checksum at sender's side... Compute the checksum at receiver's side.</h4>
                            <p>We use 8-bit 1's complement arithmetic (add, and wrap any carry-out bit).</p>
                            <p><strong>Sender Side (Data):</strong>
                                <code>11001100</code> (204)
                                <code>10101010</code> (170)
                                <code>11110000</code> (240)
                                <code>11000011</code> (195)
                            </p>
                            <pre>
  11001100
+ 10101010
----------
1 01110110  -> Wrap carry: 01110110 + 1 = 01110111

  01110111
+ 11110000
----------
1 01100111  -> Wrap carry: 01100111 + 1 = 01101000

  01101000
+ 11000011
----------
1 00101011  -> Wrap carry: 00101011 + 1 = 00101100
                            </pre>
                            <p>Final Sum = <code>00101100</code>.
                            <strong>Checksum</strong> (1's complement of sum) = <strong><code>11010011</code></strong>.</p>
                            
                            <p><strong>Receiver Side (Data + Checksum):</strong>
                                <code>11001100</code> (204)
                                <code>10101011</code> (171) <-- ERROR!
                                <code>11110000</code> (240)
                                <code>11000011</code> (195)
                                <code>11010011</code> (211) <-- Checksum
                            </p>
                            <pre>
  11001100
+ 10101011
----------
1 01110111  -> Wrap carry: 01110111 + 1 = 01111000

  01111000
+ 11110000
----------
1 01101000  -> Wrap carry: 01101000 + 1 = 01101001

  01101001
+ 11000011
----------
1 00101100  -> Wrap carry: 00101100 + 1 = 00101101

  00101101 (Sum of received data)
+ 11010011 (Received checksum)
----------
1 00000000  -> Wrap carry: 00000000 + 1 = 00000001
                            </pre>
                            <p>Final receiver sum = <code>00000001</code>.
                            The 1's complement of this is <code>11111110</code>.</p>
                            <p><strong>Conclusion:</strong> The result is <strong>NOT</strong> <code>00000000</code> (or all ones, depending on check method). Therefore, the receiver detects that <strong>an error has occurred</strong>.</p>
                        </div>
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2025 - Q5.a). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>b. How many phases are there in TCP congestion control algorithm...</h4>
                            <p>TCP congestion control has three main phases/states, governed by the <strong>Congestion Window (<code>cwnd</code>)</strong>:</p>
                            <ol>
                                <li><strong>Slow Start:</strong> At the beginning, <code>cwnd</code> = 1 MSS. It grows *exponentially*, doubling every RTT (it adds 1 MSS for every ACK received). This continues until <code>cwnd</code> reaches the <strong>threshold (<code>ssthresh</code>)</strong>.</li>
                                <li><strong>Congestion Avoidance:</strong> Once <code>cwnd</code> > <code>ssthresh</code>, growth slows to be *linear* (it adds 1 MSS per RTT). This probes for more bandwidth more gently.</li>
                                <li><strong>Congestion Detection / Fast Recovery:</strong> This is the reaction to packet loss.
                                    <ul>
                                        <li><strong>On Timeout (severe loss):</strong> The <code>ssthresh</code> is set to <code>cwnd / 2</code>. <code>cwnd</code> is reset to 1, and it re-enters <strong>Slow Start</strong>.</li>
                                        <li><strong>On 3 Duplicate ACKs (mild loss):</strong> The <code>ssthresh</code> is set to <code>cwnd / 2</code>. <code>cwnd</code> is also set to <code>ssthresh</code>. It skips Slow Start and enters <strong>Congestion Avoidance/Fast Recovery</strong>.</li>
                                    </ul>
                                </li>
                            </ol>
                            <p>The <strong>threshold value (<code>ssthresh</code>)</strong> is the "memory" of the last congestion event. It is initially set to a large value, but when packet loss occurs, it is set to half of the current congestion window, marking the point where the network is believed to be congested.</p>
                        </div>
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2023 - Q4.c and 2025 - Q4.b). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>c. What is the drawback of stop-and-wait protocol? How it can be solved and what protocols can be used...</h4>
                            <p><strong>Drawback:</strong></p>
                            <p>The primary drawback of Stop-and-Wait is its extreme <strong>inefficiency</strong>. The sender sends one packet and then *stops* and *waits* for an ACK. The entire link is idle for the full Round Trip Time (RTT). This is a low "utilization" problem. In a network with a high bandwidth-delay product (e.g., fast, long-distance links), Stop-and-Wait might use less than 0.1% of the available capacity.</p>
                            <p><strong>How to solve it:</strong></p>
                            <p>The problem is solved using <strong>pipelining</strong>. Pipelining allows the sender to send *multiple* packets (a "window" of N packets) before it needs to receive the ACK for the first packet. This keeps the "pipe" full of data and dramatically increases efficiency.</p>
                            <p><strong>Protocols that use pipelining:</strong></p>
                            <ol>
                                <li><strong>Go-Back-N (GBN)</strong></li>
                                <li><strong>Selective Repeat (SR)</strong></li>
                            </ol>
                        </div>
                    </div>
                </details>

                <!-- Q5 2024 -->
                <details>
                    <summary>Question 5</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <h4>a. We know that a router typically consist of... hardware and... software? ...data plane and control plane...</h4>
                            <p><strong>Router Components (HW vs SW):</strong></p>
                            <ul>
                                <li><strong>Input/Output Ports:</strong> Implemented in <strong>Hardware</strong>. Physical and Link-layer operations (receiving bits, checking MACs, queueing) must happen at "line speed," which requires dedicated hardware.</li>
                                <li><strong>Switching Fabric:</strong> Implemented in <strong>Hardware</strong>. This is the high-speed backplane that connects input ports to output ports. It must be hardware to forward millions of packets per second.</li>
                                <li><strong>Routing Processor:</strong> Implemented in <strong>Software</strong>. This is the router's "brain." It runs complex programs like routing protocols (OSPF, BGP) to build the forwarding table. This logic is too complex and changes too often for hardware.</li>
                            </ul>
                            <p><strong>Data Plane vs. Control Plane:</strong></p>
                            <ul>
                                <li><strong>Data Plane:</strong> This is the "fast path" that forwards individual packets.
                                    <ul>
                                        <li><strong>Implementation:</strong> <strong>Hardware</strong> (Input ports, switching fabric, output ports).</li>
                                        <li><strong>Why:</strong> For pure speed. Its job is simple: look up destination in forwarding table, send to output port. This must be done in nanoseconds.</li>
                                    </ul>
                                </li>
                                <li><strong>Control Plane:</strong> This is the "slow path" that "thinks" about the network.
                                    <ul>
                                        <li><strong>Implementation:</strong> <strong>Software</strong> (Routing processor).</li>
                                        <li><strong>Why:</strong> Its job is complex: run routing algorithms, communicate with other routers, build the forwarding table. These are high-level logic tasks, not per-packet actions.</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2023 - Q5.b). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>b. A: ...divide this network into 4 subnets... B: What is the subnetwork address for a host...</h4>
                            <p><strong>A: Divide 200.1.2.0 (Class C, /24) into 4 subnets.</strong></p>
                            <ul>
                                <li>Need 4 subnets. $2^s \ge 4$. So we need $s = 2$ subnet bits.</li>
                                <li>New mask = 24 + 2 = <strong>/26</strong> (or <code>255.255.255.192</code>).</li>
                                <li>Block size = 256 - 192 = 64.</li>
                                <li><strong>Subnet 1:</strong> <code>200.1.2.0/26</code></li>
                                <li><strong>Subnet 2:</strong> <code>200.1.2.64/26</code></li>
                                <li><strong>Subnet 3:</strong> <code>200.1.2.128/26</code></li>
                                <li><strong>Subnet 4:</strong> <code>200.1.2.192/26</code></li>
                            </ul>
                            <p><strong>B: Subnetwork address for 200.10.5.68/28.</strong></p>
                            <ul>
                                <li>IP: <code>200.10.5.68</code></li>
                                <li>Mask: /28 = <code>255.255.255.240</code>.</li>
                                <li>Block size = 256 - 240 = 16.</li>
                                <li>We need the multiple of 16 that is less than or equal to 68.</li>
                                <li>(16*1=16, 16*2=32, 16*3=48, 16*4=64, 16*5=80)</li>
                                <li>The correct multiple is 64.</li>
                                <li>Subnetwork address: <strong>200.10.5.64</strong></li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2023 - Q5.c and 2025 - Q5.b). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>c. Explain the working functionality of... DHCP, NAT, ICMP, IP Security in IPV4</h4>
                            <ol>
                                <li><strong>DHCP (Dynamic Host Configuration Protocol):</strong>
                                    <ul>
                                        <li><strong>Function:</strong> Automatically assigns IP addresses to devices on a network.
                                        <li><strong>Process (DORA):</strong> 
                                            <strong>D</strong>iscover (Client broadcasts: "Any DHCP servers?"), 
                                            <strong>O</strong>ffer (Server replies: "You can have this IP"), 
                                            <strong>R</strong>equest (Client broadcasts: "I'll take that IP"), 
                                            <strong>A</strong>cknowledge (Server confirms: "It's yours").
                                        </li>
                                    </ul>
                                </li>
                                <li><strong>NAT (Network Address Translation):</strong>
                                    <ul>
                                        <li><strong>Function:</strong> Allows multiple devices with private IPs to share one public IP.
                                        <li><strong>Process:</strong> The router rewrites the source IP and port on outgoing packets and uses a "NAT table" to rewrite the destination IP and port on incoming packets. (See 2025 Q5.b. for full detail).</li>
                                    </ul>
                                </li>
                                <li><strong>ICMP (Internet Control Message Protocol):</strong>
                                    <ul>
                                        <li><strong>Function:</strong> A network-layer "control" protocol used for error reporting and diagnostics.
                                        <li><strong>Examples:</strong> <code>ping</code> uses ICMP Echo Request/Reply. <code>traceroute</code> uses ICMP Time Exceeded messages. A router sends an ICMP Destination Unreachable if it can't forward a packet.</li>
                                    </ul>
                                </li>
                                <li><strong>IPsec (IP Security):</strong>
                                    <ul>
                                        <li><strong>Function:</strong> A suite of protocols that provides security (encryption and authentication) at the Network Layer (L3).
                                        <li><strong>Modes:</strong>
                                            <strong>Tunnel Mode:</strong> Encrypts the *entire* original IP packet (header + data) and puts it in a new IP packet. Used to create VPNs between routers.
                                            <strong>Transport Mode:</strong> Encrypts *only the payload* (e.g., TCP segment). Used for host-to-host security.
                                        </li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </div>
                </details>

            </div>
        </details>
        
        <!-- Paper 2023 -->
        <details class="mb-4">
            <summary class="text-xl">TCS-604 End Semester Examination - June 2023</summary>
            <div class="space-y-4 bg-white">
                
                <!-- Q1 2023 -->
                <details>
                    <summary>Question 1</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <h4>a. Explain TCP/IP protocol stack with diagram and proper functionality of each layer.</h4>
                            <p>The 5-layer TCP/IP (or Internet) protocol stack:</p>
                            <ol>
                                <li><strong>Application Layer (L5):</strong>
                                    <ul>
                                        <li><strong>Functionality:</strong> Provides services to network applications. This is where protocols users interact with (like HTTP, SMTP, DNS) live.
                                        <li><strong>PDU:</strong> Message</li>
                                    </ul>
                                </li>
                                <li><strong>Transport Layer (L4):</strong>
                                    <ul>
                                        <li><strong>Functionality:</strong> Provides process-to-process communication, using port numbers. It handles reliability (TCP) or "best-effort" delivery (UDP), along with flow control and congestion control.</li>
                                        <li><strong>PDU:</strong> Segment (TCP) or Datagram (UDP)</li>
                                    </ul>
                                </li>
                                <li><strong>Network Layer (L3):</strong>
                                    <ul>
                                        <li><strong>Functionality:</strong> Responsible for routing packets from the source *host* to the destination *host* across multiple networks. It uses logical IP addresses.</li>
                                        <li><strong>PDU:</strong> Datagram</li>
                                    </ul>
                                </li>
                                <li><strong>Link Layer (L2):</strong>
                                    <ul>
                                        <li><strong>Functionality:</strong> Responsible for moving data between *adjacent nodes* (e.g., host-to-router) on the same link. It uses physical MAC addresses and handles error detection.</li>
                                        <li><strong>PDU:</strong> Frame</li>
                                    </ul>
                                </li>
                                <li><strong>Physical Layer (L1):</strong>
                                    <ul>
                                        <li><strong>Functionality:</strong> Responsible for transmitting the raw *bits* of a frame over the physical medium (e.g., copper cable, fiber, radio waves).</li>
                                        <li><strong>PDU:</strong> Bits</li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                        <div class="question-block">
                            <h4>b. Define the working functionality of the circuit and packet switching with the help of a suitable diagram.</h4>
                            <p><strong>Circuit Switching:</strong></p>
                            <ul>
                                <li><strong>Concept:</strong> A dedicated, end-to-end physical connection (a "circuit") is established *before* data transfer begins.</li>
                                <li><strong>Phases:</strong> 1. Connection Setup, 2. Data Transfer, 3. Teardown.</li>
                                <li><strong>Functionality:</strong> Resources (e.g., a time slot, a frequency) are *reserved* for the entire duration of the call. This guarantees bandwidth and zero congestion, but is inefficient, as the resources are wasted if no data is being sent (e.g., silence in a phone call).</li>
                                <li><strong>Example:</strong> The old telephone network (PSTN).</li>
                            </ul>
                            <p><strong>Packet Switching:</strong></p>
                            <ul>
                                <li><strong>Concept:</strong> Data is broken into small blocks called "packets". Each packet is sent independently, with headers indicating its destination.</li>
                                <li><strong>Functionality:</strong> Packets travel from router to router in a "store-and-forward" manner. Resources are *shared* (statistical multiplexing). Multiple users' packets can be interleaved on the same link. This is highly efficient but can lead to congestion, variable delay (jitter), and packet loss.</li>
                                <li><strong>Example:</strong> The Internet.</li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2024 - Q1.c). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>c. Consider two host A and B... Find the distance m so that $d_{prop}$ equals $d_{trans}$.</h4>
                            <p>Given:</p>
                            <ul>
                                <li>Propagation speed (s) = $2.5 \times 10^8$ m/s</li>
                                <li>Packet size (L) = 100 bits</li>
                                <li>Bandwidth (R) = 28 Kbps = 28,000 bits/sec</li>
                            </ul>
                            <p>We need to find distance `m` where $d_{prop} = d_{trans}$.</p>
                            <ol>
                                <li>m / s = L / R</li>
                                <li>m = (L * s) / R</li>
                                <li>m = (100 bits * $2.5 \times 10^8$ m/s) / 28,000 bits/s</li>
                                <li>m ≈ <strong>892,857 meters</strong> (or 892.86 km)</li>
                            </ol>
                        </div>
                    </div>
                </details>

                <!-- Q2 2023 -->
                <details>
                    <summary>Question 2</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <h4>a. Explain the working of cookies, proxy server and conditional GET...</h4>
                            <p><strong>Cookies:</strong></p>
                            <ul>
                                <li><strong>Function:</strong> Used to maintain state (e.g., a login session) for the stateless HTTP protocol.</li>
                                <li><strong>Process:</strong> The server sends a <code>Set-Cookie:</code> header. The browser stores it and sends it back to that same server with every future request in a <code>Cookie:</code> header. (See 2025 Q4.a. for full detail).</li>
                            </ul>
                            <p><strong>Proxy Server (Web Proxy):</strong></p>
                            <ul>
                                <li><strong>Function:</strong> An intermediary server that clients send requests to. The proxy then fetches the content from the real server on the client's behalf.</li>
                                <li><strong>Uses:</strong> <strong>Caching</strong> (storing popular pages to serve them faster), <strong>Filtering</strong> (blocking access to websites), and <strong>Anonymity</strong> (hiding the client's IP).</li>
                            </ul>
                            <p><strong>Conditional GET:</strong></p>
                            <ul>
                                <li><strong>Function:</strong> Allows a browser to ask the server to send a page *only if it has changed*.</li>
                                <li><strong>Process:</strong> The browser stores the <code>Last-Modified</code> date of a page. On the next request, it sends this date in an <code>If-Modified-Since:</code> header. If the page hasn't changed, the server replies with <code>304 Not Modified</code> (empty body), saving bandwidth. If it has, it sends <code>200 OK</code> with the new page.</li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <h4>b. Explain the working functionality of the DNS...</h4>
                            <p><strong>DNS (Domain Name System)</strong> translates human-readable names (<code>google.com</code>) into IP addresses (<code>142.250.196.196</code>). It's a distributed, hierarchical database.</p>
                            <p><strong>Iterative Query Process:</strong></p>
                            <ol>
                                <li>Your host asks its <strong>Local Resolver</strong>.</li>
                                <li>Resolver asks a <strong>Root Server</strong> -> Root points to the <strong>TLD Server</strong> (for <code>.com</code>).</li>
                                <li>Resolver asks the <strong>TLD Server</strong> -> TLD points to the <strong>Authoritative Server</strong> (for <code>google.com</code>).</li>
                                <li>Resolver asks the <strong>Authoritative Server</strong> -> Authoritative server gives the <strong>IP address</strong>.</li>
                                <li>Resolver gives the IP to your host and *caches* the result.</li>
                            </ol>
                        </div>
                        <div class="question-block">
                            <h4>c. What are the different mail access protocols? Explain the working of any two.</h4>
                            <p>Mail *transfer* uses <strong>SMTP</strong>. Mail *access* uses <strong>POP3, IMAP, or HTTP (webmail)</strong>.</p>
                            <ol>
                                <li><strong>SMTP (Simple Mail Transfer Protocol):</strong>
                                    <ul>
                                        <li><strong>Working:</strong> This is a "push" protocol used to send email from a client to its server, and from that server to the recipient's server. It is not used to read email.</li>
                                    </ul>
                                </li>
                                <li><strong>POP3 (Post Office Protocol 3):</strong>
                                    <ul>
                                        <li><strong>Working:</strong> This is a "pull" protocol. The client connects, authenticates, and downloads all new emails to the local machine. By default, messages are *deleted* from the server after download. It's a "download and delete" model that keeps state on the client.</li>
                                    </ul>
                                </li>
                                <li><strong>IMAP (Internet Message Access Protocol):</strong>
                                    <ul>
                                        <li><strong>Working:</strong> This is also a "pull" protocol, but it *syncs* with the server. All emails and folders are kept on the server. The client (e.g., phone, laptop) just displays a local copy. State (read/unread, folders) is kept on the server and synced across all devices. This is the modern, more flexible standard.</li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </div>
                </details>

                <!-- Q3 2023 -->
                <details>
                    <summary>Question 3</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <h4>a. What are the different services provided by the Transport layer? Explain the difference between connection-oriented and less services.</h4>
                            <p><strong>Transport Layer Services:</strong> (See 2024 Q3.a. for full list).</p>
                            <ul>
                                <li>Process-to-Process Delivery (Ports)</li>
                                <li>Multiplexing / Demultiplexing</li>
                                <li>Connection-Oriented Service (TCP)</li>
                                <li>Connectionless Service (UDP)</li>
                                <li>Error Checking (Checksum)</li>
                            </ul>
                            <p><strong>Connection-Oriented (e.g., TCP):</strong></p>
                            <ul>
                                <li>Establishes a connection (3-way handshake) before sending data.</li>
                                <li><strong>Guarantees reliable, in-order delivery</strong> using ACKs, sequence numbers, and retransmissions.</li>
                                <li>Higher overhead. Used for web, email, files.</li>
                            </ul>
                            <p><strong>Connectionless (e.g., UDP):</strong></p>
                            <ul>
                                <li>No connection setup. Just sends packets.</li>
                                <li><strong>Provides "best-effort" delivery</strong>. No guarantees. Packets can be lost, reordered, or duplicated.</li>
                                <li>Very low overhead. Used for DNS, VoIP, gaming (where speed > perfect reliability).</li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <h4>b. Explain the working functionality of the TCP header segment with a suitable diagram.</h4>
                            <p>A TCP header is typically 20 bytes long (without options).</p>
                            <p><strong>Key Fields:</strong></p>
                            <ul>
                                <li><strong>Source Port</strong> (16 bits) / <strong>Destination Port</strong> (16 bits): Identifies the sending and receiving applications (processes).</li>
                                <li><strong>Sequence Number</strong> (32 bits): Used for ordering. The byte-stream number of the first byte in this segment.</li>
                                <li><strong>Acknowledgment Number</strong> (32 bits): If ACK flag is set, this is the sequence number of the *next* byte the sender is expecting.</li>
                                <li><strong>Header Length</strong> (4 bits): Size of the header in 32-bit words.</li>
                                <li><strong>Flags</strong> (e.g., <strong>SYN, ACK, FIN, RST</strong>): Control bits to manage the connection (setup, teardown, reset).</li>
                                <li><strong>Window Size</strong> (16 bits): The Receive Window (<code>rwnd</code>) used for *flow control*.</li>
                                <li><strong>Checksum</strong> (16 bits): Error-detection for the header and data.</li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2024 - Q3.c). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>c. ...what would be the IP address of E0... what would be the IP address of S0...</h4>
                            <p>Network: <code>192.168.10.0/28</code>. Block size = 16. Skip subnet .0.</p>
                            
                            <p><strong>A: IP of E0 (eighth subnet, last available IP):</strong></p>
                            <ul>
                                <li>Subnet 8 is <strong>.128</strong>.</li>
                                <li>Host Range: .129 to .142.</li>
                                <li>Last available IP: <strong>192.168.10.142</strong></li>
                            </ul>
                            
                            <p><strong>B: IP of S0 (first subnet, last available IP):</strong></p>
                            <ul>
                                <li>First subnet is <strong>.16</strong>.</li>
                                <li>Host Range: .17 to .30.</li>
                                <li>Last available IP: <strong>192.168.10.30</strong></li>
                            </ul>
                        </div>
                    </div>
                </details>

                <!-- Q4 2023 -->
                <details>
                    <summary>Question 4</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2024 - Q4.a). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>a. ...Compute the checksum at sender's side... Compute the checksum at receiver's side.</h4>
                            <p><strong>Sender Side:</strong></p>
                            <ul>
                                <li>Data: <code>11001100</code>, <code>10101010</code>, <code>11110000</code>, <code>11000011</code></li>
                                <li>Final Sum = <code>00101100</code></li>
                                <li><strong>Checksum</strong> (1's complement) = <strong><code>11010011</code></strong></li>
                            </ul>
                            <p><strong>Receiver Side:</strong></p>
                            <ul>
                                <li>Received Data: <code>11001100</code>, <code>10101011</code> (Error), <code>11110000</code>, <code>11000011</code></li>
                                <li>Received Checksum: <code>11010011</code></li>
                                <li>Final Sum (of all 5 blocks) = <code>00000001</code></li>
                            </ul>
                            <p><strong>Conclusion:</strong> The result is not all-zeros (or all-ones). <strong>An error is detected.</strong></p>
                        </div>
                        <div class="question-block">
                            <h4>b. Explain the connection establishment concept of TCP with a suitable diagram.</h4>
                            <p>This is the <strong>Three-Way Handshake</strong>:</p>
                            <ol>
                                <li><strong>Client -> Server:</strong> Sends a <strong>SYN</strong> packet (<code>Seq=x</code>). "Hi, I'd like to connect."</li>
                                <li><strong>Server -> Client:</strong> Receives SYN. Replies with a <strong>SYN-ACK</strong> packet (<code>Seq=y, Ack=x+1</code>). "I acknowledge your request and I'd also like to connect."</li>
                                <li><strong>Client -> Server:</strong> Receives SYN-ACK. Replies with an <strong>ACK</strong> packet (<code>Seq=x+1, Ack=y+1</code>). "I acknowledge your acknowledgment. The connection is open."</li>
                            </ol>
                        </div>
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2024 - Q4.c and 2025 - Q4.b). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>c. Explain the working functionality of... Stop-and-wait, Go Back N, Selective Repeat</h4>
                            <ul>
                                <li><strong>Stop-and-Wait:</strong> Sender window = 1. Sends packet 1, stops, waits for ACK 1. Very inefficient.</li>
                                <li><strong>Go-Back-N (GBN):</strong> Sender window = N. Sends packets 1,2,3... Uses *cumulative ACKs*. If packet `n` is lost, sender retransmits `n` *and all packets after it* (`n+1, n+2...`).</li>
                                <li><strong>Selective Repeat (SR):</strong> Sender window = N. Sends packets 1,2,3... Uses *individual ACKs*. If packet `n` is lost, sender retransmits *only packet `n`*. Most efficient.</li>
                            </ul>
                        </div>
                    </div>
                </details>

                <!-- Q5 2023 -->
                <details>
                    <summary>Question 5</summary>
                    <div class="space-y-6">
                        <div class="question-block">
                            <h4>a. Explain IP datagram Header format with suitable diagram and functionality.</h4>
                            <p>The IPv4 header is 20 bytes (without options).</p>
                            <p><strong>Key Fields:</strong></p>
                            <ul>
                                <li><strong>Version</strong> (4 bits): Set to <code>4</code> for IPv4.</li>
                                <li><strong>Header Length (IHL)</strong> (4 bits): Size of the header in 32-bit words.</li>
                                <li><strong>Total Length</strong> (16 bits): Total size of the *entire packet* (header + data).</li>
                                <li><strong>Identification, Flags, Fragment Offset:</strong> Used to manage fragmentation (when a large packet is split into smaller ones).</li>
                                <li><strong>Time To Live (TTL)</strong> (8 bits): Decremented by 1 at each router. If it hits 0, the packet is discarded (prevents infinite loops).</li>
                                <li><strong>Protocol</strong> (8 bits): Identifies the transport layer protocol (<code>6</code> for TCP, <code>17</code> for UDP).</li>
                                <li><strong>Header Checksum</strong> (16 bits): Error detection *for the header only*.</li>
                                <li><strong>Source IP Address</strong> (32 bits): The IP of the original sender.</li>
                                <li><strong>Destination IP Address</strong> (32 bits): The IP of the final recipient.</li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2024 - Q5.b). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>b. (i) ...divide this network into 4 subnets... (ii) What is the subnetwork address for a host...</h4>
                            <p><strong>(i): Divide 200.1.2.0 (Class C, /24) into 4 subnets.</strong></p>
                            <ul>
                                <li>Need 2 subnet bits -> <strong>/26</strong> mask. Block size = 64.</li>
                                <li><strong>Subnets:</strong> <code>200.1.2.0/26</code>, <code>200.1.2.64/26</code>, <code>200.1.2.128/26</code>, <code>200.1.2.192/26</code>.</li>
                            </ul>
                            <p><strong>(ii): Subnetwork address for 200.10.5.68/28.</strong></p>
                            <ul>
                                <li>Mask /28 -> Block size = 16.</li>
                                <li>Find multiple of 16 <= 68, which is 64.</li>
                                <li>Subnetwork address: <strong>200.10.5.64</strong></li>
                            </ul>
                        </div>
                        <div class="question-block">
                            <div class="repeat-note">
                                <strong>Note:</strong> This is a frequently repeated question (see 2024 - Q5.c and 2025 - Q5.b). You can find it in the "Repeated Questions" file.
                            </div>
                            <h4>c. Explain the working functionality of... DHCP, NAT, ICMP</h4>
                            <ol>
                                <li><strong>DHCP (Dynamic Host Configuration Protocol):</strong>
                                    <ul>
                                        <li><strong>Function:</strong> Automatically assigns IP addresses (and other info like DNS server, gateway) to devices when they join a network.
                                        <li><strong>Process (DORA):</strong> Discover, Offer, Request, Acknowledge.
                                        </li>
                                    </ul>
                                </li>
                                <li><strong>NAT (Network Address Translation):</strong>
                                    <ul>
                                        <li><strong>Function:</strong> Allows multiple devices with private IPs (<code>192.168.x.x</code>) to share a single public IP.
                                        <li><strong>Process:</strong> The router rewrites source IP/port on outgoing packets and destination IP/port on incoming packets using a NAT table.</li>
                                    </ul>
                                </li>
                                <li><strong>ICMP (Internet Control Message Protocol):</strong>
                                    <ul>
                                        <li><strong>Function:</strong> A network-layer protocol for error reporting and diagnostics.
                                        <li><strong>Examples:</strong> <code>ping</code> (Echo Request/Reply), <code>traceroute</code> (Time Exceeded).</li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </div>
                </details>

            </div>
        </details>

    </div>
<b></b><a href="common.html" style="display:block; text-align:center; margin-top:20px; color:#007bff;">Go to Second Page →
  </a>
  <!-- PRAY FOR A FRIEND -->
  <div style="text-align:center; background:#f5f7fa; padding:30px 15px; border-top:2px solid #ddd; margin-top:30px;">
    <img src="atul.JPEG" alt="Support Ashok Fitness"
         style="width:250px; height:auto; border-radius:12px; box-shadow:0 4px 10px rgba(0,0,0,0.2); margin-bottom:15px;">
    <div style="max-width:600px; margin:0 auto;">
      <h3 style="font-size:1.5rem; color:#2b2b2b; margin-bottom:10px;">Support Ashok Fitness</h3>
      <p style="font-size:1rem; color:#555; line-height:1.6; margin-bottom:15px;">
        Ashok Fitness is currently open to DATE.
        
      </p>
      
    </div>
  </div>



</body>
</html>

